Design: We began with our main that read in user input arguments and used logic checks to make sure that number of arguments and the arguments themselves were valid. Based on the number of arguments, it would call our function listdir with a mode (3 arguments = no start directory, no output directory, 5 arguments = either start or output directory specified, etc). Listdir was a function that read through all the content in the current directory. If the entry was a directory, we forked a new process and recursively called listdir again to traverse through that sub-directory in depth-first-search style, while the parent process waited for those series of child processes to finish. If the entry was a csv, we fork a process, check if it was a valid csv to sort in the first place using the category given, and call our sorter function from asst0 accordingly. Before we sort, we also check if we already sorted the current file, as to not redudantly sort any files. Finally, for any garbage (.txt, etc) files, we would also fork a process, and our program would determine that no sort was necessary, and exit that process. 
At the start of main, we getpid() of the initial process and pipe it to a file stream. At the beginning of each fork, we store getpid() of the current process and pipe it to a file stream with a comma at the end of it. At the end, we print the initial pid as well as all child pid's, and use a while loop to count the number of commas in order to get the correct number of child processes.

Difficulties: We had issues forking. We would heap buffer overflow often because our program would continually reach an instance where it would not return properly. We later realized we forgot to include a return statement in our sorter function. We also had issues making our pipe work properly. While reading the pipe, we had issues with reading the proper number of bytes and formatting our output correctly. We also had numerous smaller issues throughout the code, mostly indexing or mismatching parenthesis causing logical errors. We also had trouble because our code would sort -sorted- files over and over, until we successfully implemented a check for duplicates. Lastly, we had trouble keeping track of the data that was being passed in between different processes, as well as figuring out how to communicate appropriately between different forked processes.

Test Procedure: We created our own directory filled with .csv files, sub-directories that also included sub-directories, and nosie files. We checked to see that if the user specified an output directory, that all the sorted files were being stored there, as well as checked to see if the program started at any specified start directory. Using our universal test case, we were also able to see that noise files and already sorted files were being ignored. To check the error cases, we used several different combinations of user input, both valid and invalid.
